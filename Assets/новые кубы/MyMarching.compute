// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel March
#include "/MarchTables.compute"

static const int numThreads = 8;

struct Triangle {
    float3 vertexC;
    float3 vertexB;
    float3 vertexA;
};
/*
struct walkpoint {
    float3 pos;
    float weight;
    int angle;
    int iter;
};*/

AppendStructuredBuffer<Triangle> triangles;
//AppendStructuredBuffer<walkpoint> walkpoints;
RWStructuredBuffer<float> points;
RWStructuredBuffer<float4> destroyers;
RWStructuredBuffer<int> connectors;

float3 chunkpos;
int numPointsPerAxis;
float isoLevel;
float scale;

float3 interpolateVerts(float4 v1, float4 v2) {
    float t = (isoLevel - v1.w) / (v2.w - v1.w);
    return v1.xyz + t * (v2.xyz - v1.xyz);
    //return (v2.xyz + v1.xyz)/2;
}

int indexFromCoord(int x, int y, int z) {
    return z * numPointsPerAxis * numPointsPerAxis + y * numPointsPerAxis + x;
}

float dist(float3 a, float3 b) {
    float dis;
    float rsx = (a.x - b.x) * (a.x - b.x);
    float rsy = (a.y - b.y) * (a.y - b.y);
    float rsz = (a.z - b.z) * (a.z - b.z);
    dis = sqrt(rsx + rsy + rsz);
    return dis;
}
[numthreads(numThreads, numThreads, numThreads)]
void March(int3 id : SV_DispatchThreadID)
{
    // Stop one point before the end because voxel includes neighbouring points

    if (id.x >= numPointsPerAxis - 1 || id.y >= numPointsPerAxis - 1 || id.z >= numPointsPerAxis - 1) {
        return;
    }
    
    

    // 8 corners of the current cube
    float4 cubeCorners[8] = {
        float4((id.x) * scale, (id.y) * scale, (id.z) * scale, points[indexFromCoord(id.x, id.y, id.z)]),
        float4((id.x + 1) * scale, (id.y) * scale, (id.z) * scale,points[indexFromCoord(id.x + 1, id.y, id.z)]),
        float4((id.x + 1) * scale, (id.y) * scale, (id.z + 1) * scale,points[indexFromCoord(id.x + 1, id.y, id.z + 1)]),
        float4((id.x) * scale, (id.y) * scale, (id.z + 1) * scale,points[indexFromCoord(id.x, id.y, id.z + 1)]),
        float4((id.x) * scale, (id.y + 1) * scale, (id.z) * scale,points[indexFromCoord(id.x, id.y + 1, id.z)]),
        float4((id.x + 1) * scale, (id.y + 1) * scale, (id.z) * scale,points[indexFromCoord(id.x + 1, id.y + 1, id.z)]),
        float4((id.x + 1) * scale, (id.y + 1) * scale, (id.z + 1) * scale,points[indexFromCoord(id.x + 1, id.y + 1, id.z + 1)]),
        float4((id.x) * scale, (id.y + 1) * scale, (id.z + 1) * scale,points[indexFromCoord(id.x, id.y + 1, id.z + 1)]),
    };
    /*
    for (int i = 0; i < destroyers.Length; ++i) 
    {
        for (int c = 0; c < 8; ++c) 
        {
            if (dist(destroyers[i].xyz, cubeCorners[c].xyz) < destroyers[i].w)
            {
                if (cubeCorners[c].w > 7)
                {
                    cubeCorners[c].w -= (destroyers[i].w / dist(destroyers[i].xyz, cubeCorners[c].xyz));
                }
                if (c == 0) {
            //        points[indexFromCoord(id.x, id.y, id.z)].w -= ((destroyers[i].w / dist(destroyers[i].xyz, points[indexFromCoord(id.x, id.y, id.z)].xyz)));
                }
            }
        }
    }*/
    // Calculate unique index for each cube configuration.
    // There are 256 possible values
    // A value of 0 means cube is entirely inside surface; 255 entirely outside.
    // The value is used to look up the edge table, which indicates which edges of the cube are cut by the isosurface.
    int cubeIndex = 0;
    if (cubeCorners[0].w < isoLevel) cubeIndex |= 1;
    if (cubeCorners[1].w < isoLevel) cubeIndex |= 2;
    if (cubeCorners[2].w < isoLevel) cubeIndex |= 4;
    if (cubeCorners[3].w < isoLevel) cubeIndex |= 8;
    if (cubeCorners[4].w < isoLevel) cubeIndex |= 16;
    if (cubeCorners[5].w < isoLevel) cubeIndex |= 32;
    if (cubeCorners[6].w < isoLevel) cubeIndex |= 64;
    if (cubeCorners[7].w < isoLevel) cubeIndex |= 128;

    //if (cubeCorners[0].w<isoLevel&&cubeIndex < 255) {
    if (cubeIndex>0&&cubeIndex < 255&& cubeCorners[0].x%0.25==0&& cubeCorners[0].y%0.25==0&& cubeCorners[0].z%0.25==0) {
    //if (cubeCorners[0].w>6.96&&cubeCorners[0].w<7&& cubeCorners[0].x%0.5==0&& cubeCorners[0].y%0.5==0&& cubeCorners[0].z%0.5==0) {
    //    walkpoint wp;
     //   wp.pos = cubeCorners[0].xyz;// +chunkpos;
       // wp.pos = interpolateVerts(cubeCorners[0], cubeCorners[7]);
     //   wp.weight = 0;
     //   wp.iter = 0;
    //    wp.angle = cubeIndex;
        /*
        float3 v = 
            (cubeCorners[0].w < isoLevel) * float3(-1,-1,-1) + (cubeCorners[1].w < isoLevel) * float3(+1,-1,-1) +(cubeCorners[2].w < isoLevel) * float3(+1,-1,+1) +(cubeCorners[3].w < isoLevel) * float3(-1,-1,+1) +
            (cubeCorners[4].w < isoLevel) * float3(-1,+1,-1) + (cubeCorners[5].w < isoLevel) * float3(+1,+1,-1) +(cubeCorners[6].w < isoLevel) * float3(+1,+1,+1) +(cubeCorners[7].w < isoLevel) * float3(-1,+1,+1) ;
        v /= 8;
        float3 v0 = float3(0,1,0);
        float a = 1;

        float bx = length(float2(v.x,v.y));
        float cx = sqrt((v.x-v0.x)*(v.x-v0.x)+(v.y-v0.y)*(v.y-v0.y));
        wp.angle = acos((a*a+cx*cx-bx*bx)/(2*a*cx));

        float bz = length(float2(v.x, v.z));
        float cz = sqrt((v.x - v0.x) * (v.x - v0.x) + (v.z - v0.z) * (v.z - v0.z));
        wp.Yangle = acos((a*a+cz*cz-bz*bz)/(2*a*cz));*/
        //wp.angle = cubeIndex;
        //wp.Yangle = 0;
      //  walkpoints.Append(wp);


        //соединения с другими чанками
        if (cubeCorners[0].x == 0) {
            connectors[0] = 1;
        }
        if (cubeCorners[0].y == 0) {
            connectors[1] = 1;
        }
        if (cubeCorners[0].z == 0) {
            connectors[2] = 1;
        }
    }


    // Create triangles for current cube configuration
    for (int i = 0; triangulation[cubeIndex][i] != -1; i += 3) {
        // Get indices of corner points A and B for each of the three edges
        // of the cube that need to be joined to form the triangle.
        int a0 = cornerIndexAFromEdge[triangulation[cubeIndex][i]];
        int b0 = cornerIndexBFromEdge[triangulation[cubeIndex][i]];

        int a1 = cornerIndexAFromEdge[triangulation[cubeIndex][i + 1]];
        int b1 = cornerIndexBFromEdge[triangulation[cubeIndex][i + 1]];

        int a2 = cornerIndexAFromEdge[triangulation[cubeIndex][i + 2]];
        int b2 = cornerIndexBFromEdge[triangulation[cubeIndex][i + 2]];

        Triangle tri;
        tri.vertexA = interpolateVerts(cubeCorners[a0], cubeCorners[b0]);
        tri.vertexB = interpolateVerts(cubeCorners[a1], cubeCorners[b1]);
        tri.vertexC = interpolateVerts(cubeCorners[a2], cubeCorners[b2]);
        triangles.Append(tri);
    }


}
#pragma kernel Dest


[numthreads(numThreads, numThreads, numThreads)]
void Dest(int3 id : SV_DispatchThreadID)
{
    if (points[indexFromCoord(id.x, id.y, id.z)] < 0) { return; }
    float3 dxyz = float3((id.x) * scale, (id.y) * scale, (id.z) * scale);
    for (int i = 0; i < destroyers.Length; ++i)
    {
        if (dist(destroyers[i].xyz, dxyz) < destroyers[i].w)
        {
            //points[indexFromCoord(id.x, id.y, id.z)] = 6;// ((destroyers[i].w / dist(destroyers[i].xyz, dxyz)));
            points[indexFromCoord(id.x, id.y, id.z)] -= ((destroyers[i].w / dist(destroyers[i].xyz, dxyz)))*2.5;
            connectors[3] = 1;
        }
    }

}
